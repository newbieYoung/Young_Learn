<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tilemap</title>
    <style>
      body,
      html {
        background-color: #fff;
        margin: 0px;
        height: 100%;
        overflow-x: hidden;
        overflow-y: auto;
      }
    </style>
  </head>
  <body>
    <div id="retina"></div>
    <script type="module">
      import * as THREE from "../node_modules/three/build/three.module.js";
      import { TileMap } from "./TileMap.js";

      // 渲染器
      // const width = 1067;
      // const height = 600;
      const width = window.innerWidth;
      const height = window.innerHeight;
      console.log(width + " " + height);
      console.log(window.innerWidth + " " + window.innerHeight);
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
      });
      renderer.setSize(width, height);
      renderer.setClearColor("#ffffff", 1.0);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.getElementById("retina").appendChild(renderer.domElement);

      // 相机
      const camera = new THREE.OrthographicCamera(
        width / -2,
        width / 2,
        height / 2,
        height / -2,
        -500,
        1000
      );
      camera.position.set(0, 0, 0);
      camera.up.set(0, 1, 0); //正方向
      camera.lookAt(new THREE.Vector3(0, 0, 0));

      // 场景、灯光、正方体
      const scene = new THREE.Scene();

      const manager = new THREE.LoadingManager();
      manager.onLoad = function () {
        console.log("Loading complete!");
      };
      manager.onProgress = function (url, itemsLoaded, itemsTotal) {
        console.log(
          "Loading file: " +
            url +
            ".\nLoaded " +
            itemsLoaded +
            " of " +
            itemsTotal +
            " files."
        );
      };

      const tilemapTexture = new THREE.TextureLoader(manager).load(
        "./textures/tilemap.png"
      );

      const tilemap = new TileMap({
        viewport: {
          width,
          height,
        },
        size: {
          width: 400,
          height: 400,
        },
        mapGrid: {
          row: 5,
          column: 5,
        },
        textureGrid: {
          row: 1,
          column: 2,
        },
        texture: tilemapTexture,
        status: [
          -1, -1, 1, 1, -1, -1, -1, 1, 1, 0, 1, 1, 1, 0, -1, 1, 1, 0, -1, -1,
          -1, 0, -1, -1, -1,
        ],
        // 偏移函数
        offset: function (row, column, itemWidth, itemHeight) {
          return {
            x: -((column + row) * itemWidth) / 2,
            y: ((row * itemHeight) / 4) * 3 - (column * itemHeight) / 4,
          };
        },
        // 区域函数
        area: function () {
          return [
            [0, 0.25],
            [0, 0.75],
            [0.5, 1],
            [1, 0.75],
            [1, 0.25],
            [0.5, 0],
          ];
        },
        // 中心函数
        center: function () {
          return {
            x: 0.5,
            y: 0.25,
          };
        },
      });
      tilemap.mesh.scale.set(0.5, 0.7, 1);
      tilemap.mesh.position.set(-20, -33, 0);
      scene.add(tilemap.mesh);

      // 事件监听
      renderer.domElement.addEventListener(
        "click",
        function (e) {
          const point = {
            x: e.clientX,
            y: e.clientY,
          };
          console.log("-- touch cast run time --");
          console.log(window.performance.now());
          const map = tilemap.touchCast(point);
          console.log(window.performance.now());
          console.log(map);
          tilemap.updateGrids([
            {
              row: map.row,
              column: map.column,
              state: 1,
            },
          ]);
        },
        false
      );

      // 渲染
      function render() {
        renderer.clear();
        renderer.render(scene, camera);
        requestAnimationFrame(render);
      }
      render();
    </script>
  </body>
</html>
