<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>image</title>
    <script type="text/javascript" src="./sim-tools.js"></script>
  </head>

  <body>
    <canvas id="webgl" width="200" height="200"></canvas>
    <!-- 片段着色器程序 -->
    <script id="shader-fs" type="x-shader/x-fragment">
      precision mediump float;
      varying vec2 v_TexCoord;
      uniform sampler2D u_Sampler;//纹理取样器
      void main() {

      vec4 color = texture2D(u_Sampler,v_TexCoord);
          gl_FragColor = color;
      }
    </script>
    <!-- 顶点着色器程序 -->
    <script id="shader-vs" type="x-shader/x-vertex">
      attribute vec4 a_Position; // 顶点坐标
      attribute vec2 a_TexCoord; // 纹理坐标
      varying vec2 v_TexCoord;
      void main() {
        gl_Position= a_Position;
        v_TexCoord = a_TexCoord;
      }
    </script>
    <script>
      var canvas = document.querySelector("#webgl");
      var gl = canvas.getContext("webgl");
      var shaderProgram = initShaders(gl);
      var num = initVertexBuffers(gl, shaderProgram);
      gl.clearColor(0.0, 0.0, 1.0, 1.0);
      loadTextures(gl, shaderProgram, num, 0, "u_Sampler", "../img/sky.JPG");

      // 加载图片
      function loadTextures(gl, shaderProgram, n, texUnit, sampler, url) {
        var texture = gl.createTexture(); // 创建纹理对象
        var sampler = gl.getUniformLocation(shaderProgram, sampler);
        var image = new Image();
        image.src = url;
        image.onload = function () {
          initTextures(gl, n, texture, sampler, image, texUnit);
        };
      }

      // 初始化纹理
      function initTextures(gl, n, texture, sampler, image, texUnit) {
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1); // 对纹理图像进行y轴反转
        // 激活纹理
        gl.activeTexture(gl.TEXTURE0 + texUnit);
        gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定纹理对象
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); // 配置纹理对象的参数

        // 如果纹理中存在透明通道则需要设置为gl.RGBA，如果不存在则可以设置为gl.RGB
        gl.texImage2D(
          gl.TEXTURE_2D,
          0,
          gl.RGBA,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          image
        ); // 将纹理图像分配给纹理对象

        gl.uniform1i(sampler, texUnit); // 将对应纹理传给着色器中的取样器变量

        // draw
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, n);
      }

      // 初始化顶点位置
      function initVertexBuffers(gl, shaderProgram) {
        var datas = new Float32Array([
          //顶点坐标、纹理坐标
          -1.0, 1.0, 0.0, 1.0, -1.0, -1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 1.0,
          -1.0, 1.0, 0.0,
        ]);

        var num = 4; // 顶点数目
        var vertexBuffer = gl.createBuffer(); // 创建缓冲区对象

        // 将缓冲区对象绑定到目标并写入数据
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, datas, gl.STATIC_DRAW);

        var size = datas.BYTES_PER_ELEMENT; //数组中的每个元素的大小（以字节为单位）

        // 顶点着色器接受顶点坐标和纹理坐标映射关系
        var a_Position = gl.getAttribLocation(shaderProgram, "a_Position");
        gl.vertexAttribPointer(a_Position, 2, gl.FLOAT, false, size * 4, 0);
        gl.enableVertexAttribArray(a_Position);

        var a_TexCoord = gl.getAttribLocation(shaderProgram, "a_TexCoord");
        gl.vertexAttribPointer(
          a_TexCoord,
          2,
          gl.FLOAT,
          false,
          size * 4,
          size * 2
        );
        gl.enableVertexAttribArray(a_TexCoord);

        return num;
      }
    </script>
  </body>
</html>
