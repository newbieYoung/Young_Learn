<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>ThreeJS 几何变换</title>
        <script src="../lib/three.js"></script>
        <style type="text/css">
            div#canvas-frame {
                cursor: pointer;
                width:100%;
                height:100%;
                background-color: #EEEEEE;
            }
        </style>
    </head>
    <body onload="threeStart();">
        <div id="canvas-frame"></div>
        <script>
            var renderer;
            var width;
            var height;
            function initThree() {
                width = window.innerWidth;
                height = window.innerHeight;
                //创建渲染器
                renderer = new THREE.WebGLRenderer({
                    antialias : true
                });
                renderer.setSize(width, height);
                renderer.setClearColor(0xFFFFFF, 1.0);
                //并添加容器中
                document.getElementById('canvas-frame').appendChild(renderer.domElement);
            }

            var camera;
            function initCamera() {
            	//创建相机
                camera = new THREE.PerspectiveCamera(45, width / height, 1, 1000);
                camera.position.x = 300;
                camera.position.y = 600;
                camera.position.z = 600;
                camera.up.x = 0;//正方向
                camera.up.y = 1;
                camera.up.z = 0;
                camera.lookAt({
                    x : 0,
                    y : 0,
                    z : 0
                });
            }

            var scene;
            function initScene() {
            	//创建场景
                scene = new THREE.Scene();
            }

            var light;
            function initLight() {
            	//创建光线
                light = new THREE.DirectionalLight(0xFF0000, 1.0, 0);
                light.position.set(100, 100, 200);
                scene.add(light);
            }

            var cube;
            var plane;
            function initObject() {
                //坐标轴
                var xmat = new THREE.LineBasicMaterial({color: 0xff0000});
                var xgeo = new THREE.Geometry();
                xgeo.vertices.push(
                    new THREE.Vector3( 0, 0, 0 ),
                    new THREE.Vector3( 300, 0, 0 )
                );
                var xline = new THREE.Line( xgeo, xmat );
                scene.add( xline );

                var ymat = new THREE.LineBasicMaterial({color: 0x00ff00});
                var ygeo = new THREE.Geometry();
                ygeo.vertices.push(
                    new THREE.Vector3( 0, 0, 0 ),
                    new THREE.Vector3( 0, 300, 0 )
                );
                var yline = new THREE.Line( ygeo, ymat );
                scene.add( yline );

                var zmat = new THREE.LineBasicMaterial({color: 0x0000ff});
                var zgeo = new THREE.Geometry();
                zgeo.vertices.push(
                    new THREE.Vector3( 0, 0, 0 ),
                    new THREE.Vector3( 0, 0, 300 )
                );
                var zline = new THREE.Line( zgeo, zmat );
                scene.add( zline );

                //正方体
                var cubegeo = new THREE.BoxGeometry( 200, 200, 200 );
                for ( var i = 0; i < cubegeo.faces.length; i+=2 ) {
                    var hex = Math.random() * 0xffffff;
                    cubegeo.faces[ i ].color.setHex( hex );
                    cubegeo.faces[ i + 1 ].color.setHex( hex );
                }
                var cubemat = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors});
                cube = new THREE.Mesh( cubegeo, cubemat );
                cube.position.x = 100;
                cube.position.y = 100;
                cube.position.z = -100;
                scene.add( cube );

                var cubegeo2 = new THREE.BoxGeometry( 200, 200, 200 );
                for ( var i = 0; i < cubegeo2.faces.length; i += 2 ) {
                    var hex = Math.random() * 0xffffff;
                    cubegeo2.faces[ i ].color.setHex( hex );
                    cubegeo2.faces[ i + 1 ].color.setHex( hex );
                }
                var cubemat2 = new THREE.MeshBasicMaterial({vertexColors: THREE.FaceColors});
                cube2 = new THREE.Mesh( cubegeo2, cubemat2 );
                cube2.position.x = 100;
                cube2.position.y = 300;
                cube2.position.z = -100;
                scene.add( cube2 );
            }

            //绕着世界坐标系的某个轴旋转
            function rotateAroundWorldY(obj,rad){
                var x0 = obj.position.x;
                var z0 = obj.position.z;
                /**
                 * 因为物体本身的坐标系是随着物体的变化而变化的，
                 * 所以如果使用rotateZ、rotateY、rotateX等方法，
                 * 多次调用后就会出问题，先改为Quaternion实现。
                 */
                var q = new THREE.Quaternion(); 
                q.setFromAxisAngle( new THREE.Vector3( 0, 1, 0 ), rad );
                obj.quaternion.premultiply( q );
                //obj.rotateY(rad);
                obj.position.x = Math.cos(rad)*x0+Math.sin(rad)*z0;
                obj.position.z = Math.cos(rad)*z0-Math.sin(rad)*x0;
            }
            function rotateAroundWorldZ(obj,rad){
                var x0 = obj.position.x;
                var y0 = obj.position.y;
                var q = new THREE.Quaternion(); 
                q.setFromAxisAngle( new THREE.Vector3( 0, 0, 1 ), rad );
                obj.quaternion.premultiply( q );
                //obj.rotateZ(rad);
                obj.position.x = Math.cos(rad)*x0-Math.sin(rad)*y0;
                obj.position.y = Math.cos(rad)*y0+Math.sin(rad)*x0;
            }
            function rotateAroundWorldX(obj,rad){
                var y0 = obj.position.y;
                var z0 = obj.position.z;
                var q = new THREE.Quaternion(); 
                q.setFromAxisAngle( new THREE.Vector3( 1, 0, 0 ), rad );
                obj.quaternion.premultiply( q );
                //obj.rotateX(rad);
                obj.position.y = Math.cos(rad)*y0-Math.sin(rad)*z0;
                obj.position.z = Math.cos(rad)*z0+Math.sin(rad)*y0;
            }

            function render(timestamp){
            	//渲染
                renderer.clear();
                renderer.render(scene, camera);

                setTimeout(function(){
                	renderer.clear();

                	// 这种反转矩阵还原变换的方法有问题，不知道啥原因
                	// cube.matrix.getInverse(cube.matrix);
                	// console.log(cube.matrix);
                	// cube.applyMatrix(cube.matrix);

                    //逆矩阵回到世界坐标系原点
                	var matrix = cube.matrix.clone();
                	matrix.getInverse(matrix);
                	cube.applyMatrix(matrix);
                   
                    //绕世界坐标系y轴顺时针旋转45度
                    //rotateAroundWorldY(cube,-Math.PI*22/180);
                    //rotateAroundWorldY(cube2,-Math.PI*22/180);
                    
                    //绕世界坐标系y轴逆时针旋转45度
                    //rotateAroundWorldY(cube,Math.PI*22/180);
                    //rotateAroundWorldY(cube2,Math.PI*22/180);
                    
                    //绕世界坐标系x轴逆时针旋转45度
                    //rotateAroundWorldX(cube,Math.PI*30/180);
                    //rotateAroundWorldX(cube2,Math.PI*30/180);

                    //绕世界坐标系x轴顺时针旋转45度
                    //rotateAroundWorldX(cube,-Math.PI*180/180);
                    //rotateAroundWorldX(cube2,-Math.PI*180/180);
                    
                    //绕世界坐标系z轴顺时针旋转45度
                    //rotateAroundWorldZ(cube,-Math.PI*12/180);
                    //rotateAroundWorldZ(cube2,-Math.PI*12/180);

                    //绕世界坐标系z轴逆时针旋转45度
                    //rotateAroundWorldZ(cube,Math.PI*30/180);
                    //rotateAroundWorldZ(cube2,Math.PI*30/180);

                	renderer.render(scene, camera);
                },1000);
                
                //测试多次调用绕世界坐标轴旋转方法是否正常
                //setTimeout(function(){
                //    renderer.clear();
                //    rotateAroundWorldY(cube,Math.PI*20/180);
                //    rotateAroundWorldY(cube2,Math.PI*20/180);
                //    renderer.render(scene, camera);
                //},2000);

                /**
                 * ThreeJS中Object3D对象的几何变化基本都是相对于物体本身的坐标系而言的
                 */
                
                //绕自身X轴旋转45度
                setTimeout(function(){
                 	renderer.clear();

                    var beta = Math.PI*45/180;

                 	cube.rotateX(beta);

                    /**
                     * 首先使用矩阵时是以世界坐标系为基准的
                     */
                    var rx = new THREE.Matrix4();
                    rx.set(1,0,0,0,
                            0,Math.cos(-beta),Math.sin(-beta),0,
                            0,-Math.sin(-beta),Math.cos(-beta),0,
                            0,0,0,1);
                    //cube.applyMatrix(rx);

                 	renderer.render(scene, camera);
                },3000);

                //绕自身Y轴旋转45度
                // setTimeout(function(){
                // 	renderer.clear();
                // 	cube.rotateY(Math.PI*45/180);
                // 	renderer.render(scene, camera);
                // },3000);
            }

            function threeStart() {
                initThree();
                initCamera();
                initScene();
                initLight();
                initObject();
                render();
            }
        </script>
    </body>
</html>